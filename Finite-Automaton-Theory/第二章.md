### 有限自动机理论-第二章

---

#### 例子语言

一个字母表上的语言就是该字母表的任意字符串的集合。语言中的字符串称为该语言的句子。

语言的定义从两个方面进行：（1）从产生的角度；（2）从接收或者识别的角度

（1）从产生的角度：根据语言中的基本句子和其他句子的形成规则，产生该语言所包含的所有句子。这也就是形式语言所研究的问题。

（2）从接收或者识别的角度：使用自动机模型接收字符串，接收到的所有字符串也形成了一个语言。这个是自动机所研究的问题。

形式语言和自动机理论之间的统一性，等价性理论。

**示例：**小括号匹配串的语言

这里的字母表可以认为是左右括号的集合，语言可以认为是所有的左括号和右括号相匹配得到的串的集合，而句子可以是任意的一个前面的集合中的元素，比如说$(),(()),()()$等等都是一个句子。但同时我们注意$)(,())$等等不是该语言的句子。（注意这里要求左右匹配的问题）

如何产生这个语言，也就是如何产生该语言的所有句子？——递归提供了语言的良好定义。

除了基本句子外其他句子按照相同的方法产生（给出生成规则）

上面的例子可以这样定义：

(1) $()$是该语言最基本的句子；

(2) 如果$S$是句子，那么$(S)$是句子；

(3) 如果$S$是句子，那么$SS$是句子；

根据形成规则可以产生该语言的任意句子同时可以判断某个串是否是该语言的句子（语法分析）。

**巴科斯-诺尔范式（BNF-Backus-Naur Form）描述规则：**

1. **<括号匹配项> ::= ()**
2. **<括号匹配项> ::= (<括号匹配项>)**
3. **<括号匹配项> ::= <括号匹配项><括号匹配项>** 

Chomsky采用的符号化的描述凡是，运用规则：

1. $S\rightarrow ()$
2. $S\rightarrow (S)$
3. $S\rightarrow SS$

根据产生规则可以生成任意的句子也可以判断一个串是否为句子。

$S$称为非终结符，在推导过程中是可以被替换的符号，$($和$)$称为终结符，在推导过程中不能够再被替换为其他符号。

$\rightarrow$是产生式系统的元符号，不属于终结符，也不属于非终结符。

**例一：由偶数个0组成的串的语言。**

规则的自然语言描述方式：

1. 00是该语言的基本的句子
2. 如果$S$是句子，则$00S$是句子（换为0S0, S00或者SS均可）

**例二：高级程序设计语言中的算术表达式的形成规则**

自然语言的描述方式：

1. 单个变量是最基本的句子
2. 如果E是一个句子，那么EAE就是一个句子，其中A代表的是运算符+，-，*，/
3. 如果E是一个句子，那么$(E)$是一个句子

形式语言的描述方式：

1. $E\rightarrow i$
2. $E\rightarrow EAE$
3. $E\rightarrow (E)$
4. $A\rightarrow +$
5. $A\rightarrow -$
6. $A\rightarrow *$
7. $A\rightarrow /$

将上面的1，2，3合并为：$E\rightarrow i|EAE|(E)$

将上面的4，5，6，7合并为：$A\rightarrow +|-|*|/$

如果希望表现出运算符的优先级的产生式为：

$E\rightarrow E+T|E-T|T$

$T\rightarrow T*F|T/F|F$

$F\rightarrow (E)|i$

其中$E$代表表达式，$T$代表项，$F$代表因子，$(E)$代表的是带小括号的表达式，表示先因子，再*, /, 最后+, -

如果需要将%（取模运算）以及^（指数运算）添加进来：

E -> E+T|E-T|T

T->T*A|T/A|T%A|A

A->F^A|F

F->(E)|i

（注意^运算的结合性是右结合的）

标识符的语言。

标识符：以字母开头的字母和/或数字的串（这里仅考虑小写字母）

标识符的形成规则：单个字母就是基本的标识符，在标识符后面增加1个字母或者数字可以得到新的标识符。
$$
\begin{split}
&I\to L\\
&I\to IL\\
&I\to ID\\
&L\to a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z\\
&D\to 1|2|3|4|5|6|7|8|9|0\\
\end{split}
$$
按照标识符的定义来看，可以写为：
$$
\begin{split}
&I\to L\\
&I\to LS\\
&S\to SS|L|D\\
&L\to a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z\\
&D\to 1|2|3|4|5|6|7|8|9|0\\
\end{split}
$$
一个语言可以通过不同的产生式的组合来产生。

---

#### 文法与语言的关系

语言：字母表上通过一定规则产生的字符串的集合；语言中的字符串称为句子。

对于一类语言可以在字母表上按照句子的结构特点和构成规则定义产生该语言的**文法**。

使用文法作为相应语言的有穷描述，不仅描述结构特征还能够产生这个语言的所有句子。

##### 文法

短语结构文法PSG的定义：文法$G$由一个四元组构成：$G=(\Sigma,V,S,P)$.

$\Sigma$表示有限字符的集合，称为字母表，元素称为字母或者终结符。

$V$是一个有限字符的集合，称为非终结符集合，其元素称为变量或者非终结符。（一般使用大写字母表示）

$S$是一个特殊的非终结符，即$S\in V$. 称为文法的开始符号。

$P$是有序偶对$(\alpha,\beta)$的集合，其中$\alpha$是集合$(\Sigma\cup V)$上的字符串（但是$\alpha$至少包含一个非终结符）；$\beta$是集合$(\Sigma\cup V)^\ast$的元素（可以是$\epsilon$）。

一般来说将有序偶对$(\alpha,\beta)$记为$\alpha\to \beta$称为产生式。

**推导（派生）的定义：**

对于文法$G$来说, $\alpha$和$\beta$是集合$(\Sigma\cup V)$上的串，$\alpha=pvr,\beta=pur$（$p,r$可能同时为$\epsilon$）而$v\rightarrow u$是文法$G$的产生式，则称$\alpha$直接推导（一步推导）出$\beta$. 记为$\alpha \Rightarrow \beta$, 即$pvr\Rightarrow pur$.

推导的实质：替换。产生式的右边替换产生式的左边。

推导的逆过程称为归约。

$y \Rightarrow^+ z$表示$y$可以经过多步推导出$z$，即存在串的序列$\alpha_1,\alpha_2,\cdots,\alpha_n$; 令$y=\alpha_1,z=\alpha_n$且$\alpha_i\Rightarrow \alpha_{i+1}$.（这个对于所有的$n>i\geq 1$）

$y\Rightarrow^{\ast}z$表示$y$可以经过任意步推导出$z$，即$y=z$或者$y\Rightarrow^+z$

$S\Rightarrow ^\ast S$对于所有的文法一定成立，但是$S\Rightarrow^+ S$对于所有的文法不一定成立。

**语言的定义：**给定文法$G$，有开始符号$S$，将$S$可以推导出所有句子的集合称为由文法产生的语言，记为$L(G)$.
$$
L(G)=\{ \omega |S \Rightarrow^\ast \omega,\text{and }\omega\in \Sigma^\ast\}
$$
文法$G$产生语言$L$，必须满足：(1) G推导产生的所有句子都在$L$中；(2) L的任意句子可以由$G$推导产生。

##### 文法和语言的三类问题

（1）已知文法得到该文法产生的语言

（2）已知语言构造产生该语言的某个文法

（3）判断一个文法是否由某个语言产生

**一个语言可以由多个不同的文法产生；一个文法只能产生一个语言。**

文法$G_1$和文法$G_2$之间等价和相同的区别？

如果两个文法导出了相同的语言则认为这两个文法之间是等价的。

如何证明：证明产生的语言互为子集：$L(G_1)\subseteq L(G_2)$以及$L(G_2)\subseteq L(G_1)$. 

---

#### Chomsky对于文法，语言的分类

语言的分类是根据产生该语言文法的类别进行分类的。

0型文法：对于一般的短语结构文法(PSG) $G(\Sigma,V,S,P)$，G称为0型文法。对应的$L(G)$称为0型语言。

1型文法：如果对于任意$\alpha\rightarrow \beta\in P$. 均有$|\alpha|\leq |\beta|$成立，则称G是1型文法。（上下文相关文法CSG）

​	标准形式：$yAz\rightarrow y\omega z$. 其中$A\in V,y,z\in (\Sigma\cup V)^\ast, \omega\in (\Sigma\cup V)^+$.

2型文法：如果对于任意$\alpha\to \beta\in P$, 均有$|\alpha|\leq |\beta|,\alpha\in V$（$\alpha$是非终结符）. 称G为2型文法：上下文无关文法(CFG). 

3型文法：如果对于任意$\alpha\to \beta \in P$, 具有形式$A\to \omega$或者$A\to \omega B$. 其中$A,B\in V,w\in \Sigma^+$. 则称G是3型文法，或者右线性文法RLG，也可以称为正则文法RG.

<font color=red>如果文法G中有$\alpha\to \epsilon$产生式，则G一定是0型文法。</font>

文法分类判断方法：文法$G=(\Sigma,V,S,P)$则（1）G是短语结构文法；（2）若文法G所有产生式的左边长度小于等于右边的长度，那么G是上下文相关文法。（3）如果上下文相关G的所有产生式左边都是一个非终结符，那么G是上下文无关文法。（4）如果上下文无关文法G所有产生式右边最多只有一个非终结符且该非终结符只能出现在最右边，那么G是右线性文法。

判断文法G： $S\to 01|101S$. 这个文法G是RG, CFG, CSG, PSG.

空句子不影响产生的文法的类型。

设$G=(\Sigma,V,S,P)$表示一个文法，**如果$S$不出现在任何产生式的右边**则：

（1）如果$G$是CSG，仍然称$(\Sigma,V,S,P\cup\{S\to\epsilon\})$为CSG，产生的语言仍然为CSL.

（2）如果$G$是CFG，仍然称$(\Sigma,V,S,P\cup\{S\to\epsilon\})$为CFG，产生的语言仍然为CFL.

（3）如果$G$是RLG，仍然称$(\Sigma,V,S,P\cup\{S\to\epsilon\})$为RLG，产生的语言仍然为RLL.

注意限制条件：开始符号只能出现在产生式的左边不用出现在右边，开始符号不能当作一般的非终结符来进行处理。

**定理：**设文法$G=(\Sigma,V,S,P)$, 则存在与G同类型的文法$G'=(\Sigma',V',S',P')$使得$L(G)=L(G')$, 且$G'$的开始符号$S'$不出现在$G'$的任何产生式的右边。

---

#### 文法产生语言

递归的上下文无关文法的定义：一个上下文无关的文法$G$，如果存在$A\in V$, 有$A\Rightarrow^+\alpha A\beta$则称$A$是递归的非终结符。递归分为直接递归和间接递归。一个产生式一步推导就是直接递归的非终结符。空串产生式的作用就是在推导的过程中对于某个句型，省略掉能够产生$\epsilon$的非终结符。如果某个上下文无关文法$G$有$S\to\epsilon$, 则$L(G)$一定包含空句子$\epsilon$. 

**例题：**字母表$\{a,b\}$上所有堆成的非空串组成的语言（没有中心点），构造文法产生这个语言。

【解】首先$aa,bb$是最基本的句子。如果$S$是句子则$aSa$以及$bSb$是句子。因此我们就可以写出文法产生式。
$$
\begin{split}
&S\to aa\\
&S\to bb\\
&S\to aSa\\
&S\to bSb
\end{split}
$$
**例题：**字母表$\{a,b\}$下对于产生（1）语言$L=\{\omega d\omega^T,\omega\in \{a,b,c\}^+,d\in\{a,b\}\}$构成产生语言$L$的文法；（2）语言$L=\{\omega d\omega^T,\omega\in \{a,b,c\}^\ast,d\in\{a,b\}\}$构成产生语言$L$的文法；（3）语言$L=\{a^nb^n|n\geq 0\}$构造产生语言$L$的文法；

【解】（1）$S\to aSa|bSb|cSc|ada|bdb|cdc, d\to a|b$; （2）$S\to aSa|bSb|cSc|a|b$; （3）$S\to aSb|\epsilon$. 

小技巧：对于任意的$a,b\in \Sigma^+$, 使用$A\to ab|aAb$产生$\{a^nb^n|n>0\}$; 使用$A\to a|b|aA|bA$产生$\{a,b\}^+$;  使用$A\to a|aA$产生$\{a\}^+$; 使用$A\to \epsilon|aAb$产生$\{a^nb^n|n\geq0\}$; 使用$A\to \epsilon |aA|bA$产生$\{a,b\}^\ast$; 使用$A\to \epsilon|aA$产生$\{a\}^\ast$.

使用$A\to aAa|bAb$产生$\{\omega A \omega^T|\omega\in \{a,b\}^+\}$.

**例题：**字母表为$\{0,1\}$，构造文法分别产生$\Sigma=\{0,1\}$上的语言：
$$
\begin{split}
&(1) \{x|x=x^T,x\in \Sigma\}\\
&(2) \{x|x=x^T,x\in \Sigma^+\}\\
&(3)\{xx^T|x\in \Sigma^+\}\\
&(4)\{xx^T|x\in \Sigma^\ast\}\\
&(5) \{x0x^T|x\in \Sigma^+\}\\
&(6) \{xwx^T|x,w\in \Sigma^+\}\\
&(7)\{xx^Tw|x,w\in \Sigma^+\}
\end{split}
$$
【解】（1）串与其逆相等。$S\to 0|1$; （2）$S\to 0S0|1S1|0|1|00|11$; （3）$S\to 0S0|1S1|00|11$; （4）$S\to 0S0|1S1|\epsilon$; （5）$S\to 0S0|1S1|000|101$；（6）$S\to 0S0|1S1|0A0|1A1, A\to 0|1|0A|1A$；（7）$S\to AB, A\to 00|11|0A0|1A1,B\to0|1|0B|1B$

**例题：**构造文法产生所有的无符号数，由$\{0,1,\cdots,9\}$的10个数字符号组合而成的不允许从0开始。

【解】：使用$A$限制首位不为0的情况，使用$M$递归定义长度无限的无符号数。构造的产生式如下：
$$
\begin{split}
&N\to AM|0\\
&A\to 1|2|3|4|5|6|7|8|9\\
&M\to \epsilon|0M|1M|2M|3M|4M|5M|6M|7M|8M|9M\\
\end{split}
$$
产生语言$\{\omega|\omega\in \{0,1\}^\ast,且\omega中有相同数量的0和1\}$的文法：
$$
S\to S0S1S|S1S0S|\epsilon
$$
【难点】产生语言$L(G)=\{a^nb^nc^n|n>0\}$的文法。
$$
\begin{gather}
S\to aSBC\\
S\to aBC\\
CB\to BC\\
aB\to ab\\
bB \to bb\\
bC \to bc\\
cC\to cc\\
\end{gather}
$$
还可以简化为：
$$
S\to abc|aSBc\\
cB\to Bc\\
aB\to ab\\
bB\to bb
$$
<font color=red>难点：上下文相关文法（CSG）的构造。</font>

---

#### 无用非终结符

**定义：**一个无关文法$G$, $A\in V$，如果$A$不出现在任何形如：$S\Rightarrow^\ast uAv\Rightarrow^+u\omega v$的推导之中，则$A$为无用的非终结符。

相对而言，有用非终结符$A$必须同时满足：（1）$A$必须出现在某个句型中，（2）从$A$开始能够产生某些终结符串。

如果文法$G$的开始符号$S$是无用的非终结符号，那么$L(G)=\empty$.

---

#### 空串定理

上下文无关文法$G$存在一般的空串产生式$A\to \epsilon$, 则存在另一个上下文无关文法$G_1$使得（1）$L(G)=L(G_1)$；（2）如果$\epsilon\notin L(G)$，则$G_1$中没有任何空串产生式（$S_1$就是$S$）；（3）如果$\epsilon\in L(G)$则$G_1$中仅仅有一个空串产生式$S_1\to \epsilon$，且$S_1$不出现在$G_1$的产生式的右边。

---

#### 语言之间的运算以及其运算的封闭性

对简单语言进行运算产生复杂语言。

**封闭性：**如果任意的属于某一种语言类的一个或者多个语言在某一个特定运算下得到的语言仍然是同类的语言，则我们称该语言类对于该运算具有封闭性。

**有效封闭性：**根据一个或者多个语言的文法，如果可以构造出给定运算下的同类语言的文法则称该语言对于这种运算是有效封闭的。

本质：文法的构造

存在文法$G_1$和$G_2$，$L_1=L(G_1),L_2=L(G_2)$，需要构造文法$G$使得$L(G)$是对于$L_1,L_2$进行某种运算之后得到的语言。

（1）联合运算：$L_1,L_2$之间的联合运算为：
$$
L_1\cup L_2=\{\omega |\omega \in L_1\text{ or }\omega \in L_2\}
$$
（2）连接运算：$L_1,L_2$之间的连接运算为：
$$
L_1L_2=\{\omega|\omega=\omega_1\omega_2,\omega_1\in L_1,\omega_2\in L_2\}
$$
（3）迭代运算：语言$L_1$的迭代运算为：
$$
L_1^\ast =\{\omega|\omega=\omega_1\omega_2\cdots\omega_m,\omega_i\in L_1,m\geq 0\}=\cup L_1^n,n\geq 0
$$
$i(i=0,1,2,3)$型语言对于联合，连接和迭代运算都是有效封闭的。

假设：产生$L_1$的文法是：$G_1=(\Sigma_1,V_1,S_1,P_1)$，产生$L_2$的文法是：$G_2=(\Sigma_2,V_2,S_2,P_2)$，同时还假设$\Sigma_1\cap \Sigma_2=\empty,V_1\cap V_2=\empty,S\notin V_1,S\notin V_2$. 设置$\Sigma=\Sigma_1\cup \Sigma_2,V=V_1\cup V_2\cup \{S\}$.

构造$G_3=(\Sigma,V,S,P_3)$. 其中$P_3=\{S\rightarrow S_1\}\cup \{S\rightarrow S_2\}\cup P_1\cup P_2$. 

对于$i=0,1,2$，如果$G_1,G_2$是$i$型文法，则$G_3$依然。显然$L(G_3)=L(G_1)\cup L(G_2)$, 0,1,2型语言类对于联合运算是封闭的。对于3型而言，构造文法$G_4=(\Sigma,V,S,P_4)$其中$P_4$为$\{S\to \alpha|S_1\to \alpha在P_1中\}\cup\{S\to \beta|S_2\to \beta在P_2中\}\cup P_1\cup P_2$. 则$G_4$是RG，因此3型语言对于联合运算是封闭的。

对于连接运算构造的方式，构造$G_5$, 其中$P_5=\{S\to S_1S_2\}\cup P_1\cup P_2$. 对于$i=0,1,2$型语言，连接运算封闭。

3型文法，构造$G_6=(\Sigma,V_1\cup V_2,S_1,P_6)$. 其中$P_6$为：$\{A\to \omega B|A\to \omega B在P_1中\}\cup \{A\to \omega S_2|A\to \omega B在P_1中\}\cup P_2$

<font color=red>关于不同类型文法对于三种运算规则的封闭性的证明留到考前复习之前过一遍，现在不详述。</font>

**结论：**

不论字母表$\Sigma_1\cap\Sigma_2=\empty$或者$\Sigma_1\cap \Sigma_2\neq \empty$（包括$\Sigma_1=\Sigma_2$）四类语言对于联合，连接以及迭代运算都是有效封闭的。

右线性语言对于补和交运算是封闭的；上下文无关语言对于补和交运算不封闭。

上下文无关语言对于置换映射有效封闭。

#### 正则表达式和正则集

**定义：**正则集的定义：$L$是字母表$\Sigma$上的语言，（1）如果$L$是有限的，那么$L$是正则的；（2）如果$L$能够通过下列运算递归产生：如果$L_1,L_2$正则，且$L=L_1\cup L_2$；如果$L_1,L_2$正则，且$L=L_1 L_2$；如果$L_1$正则，且$L=L_1^\ast$那么我们认为$L$也是正则的。如果一个语言是正则的，那么该语言也称为正则集。

正则表达式$R$和它所表达的正则集$S(R)$，$\empty$是正则表达式，$S(\empty)=\empty$.

如果$R_1,R_2$均为正则表达式，则$(R_1+R_2)$是正则表达式，$S(R_1+R_2)=S(R_1)\cup S(R_2)$.

如果$R_1,R_2$均为正则表达式，则$(R_1R_2)$是正则表达式，$S(R_1R_2)=S(R_1) S(R_2)$.

如果$R$是正则表达式，则$(R)^\ast$是正则表达式，$S((R)^\ast)=(S(R))^\ast$

正则表达式$(a+b)^\ast$代表正则集: $\{a,b\}^\ast$

正则表达式$a(b+c)^\ast$代表正则集: $\{\omega|\omega以a开头的b,c组成的任意串\}$

对于每个正则集，至少能够找到表示该正则集的一个正则表达式；对于每一个正则表达式都唯一地表示一个正则集。

**例题：**正则表达式$(a+b)^2$代表语言：$\{aa,ab,ba,bb\}$.

**例题：**正则表达式$(a+b)(a+b)^\ast(a+b)$代表语言：$\{\omega|\omega\in \{a,b\}^+,且\omega长度至少为2\}$.

**例题：**正则表达式$a(a+b+c)^\ast a+b(a+b+c)^\ast b+c(a+b+c)^\ast c$代表语言：

$\{\omega|\omega\in \{a,b,c\}^+,且\omega中最后一个字母与第一个字母相同,|\omega|\geq 2\}$.

**例题：**$\{\omega|\omega\in \{a,b\}^+,且\omega中至少包含2个a和一个b\}$的正则表达式为：

$(R)^\ast a(R)^\ast a(R)^\ast b(R)^\ast+(R)^\ast a(R)^\ast b(R)^\ast a(R)^\ast+(R)^\ast b(R)^\ast a(R)^\ast a(R)^\ast$

一个3型语言，从文法角度称之为右线性语言；从运算的角度而言称之为正则语言。

